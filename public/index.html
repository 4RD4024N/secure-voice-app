<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>G√ºvenli Sesli Sohbet</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>

  <div class="glass-app">
    <header class="glass-header">
      <h1>Sesli Sohbet</h1>
      <button id="themeToggle" class="ghost glass-btn" title="Tema Deƒüi≈ütir">Tema</button>
    </header>
    <main class="glass-main">
      <section class="glass-card glass-controls">
        <input id="roomId" type="text" placeholder="Oda ID" class="glass-input" />
        <input id="displayName" type="text" maxlength="16" placeholder="ƒ∞sim" class="glass-input" />
        <div class="glass-btn-row">
          <button id="setNameBtn" class="glass-btn">ƒ∞sim Deƒüi≈ütir</button>
          <button id="createBtn" class="glass-btn">Oda Olu≈ütur</button>
          <button id="joinBtn" class="glass-btn">Katƒ±l</button>
        </div>
        <div class="glass-status-row">
          <span id="status" class="glass-status"></span>
          <span id="shareLink" class="glass-share"></span>
        </div>
        <div class="glass-row">
          <button id="refreshRooms" class="glass-btn small">Odalarƒ± Yenile</button>
          <span id="roomsList" class="glass-list">Y√ºkleniyor...</span>
        </div>
      </section>
      <section class="glass-card glass-users">
        <h2>Kullanƒ±cƒ±lar</h2>
        <ul id="user-list" class="glass-user-list"></ul>
      </section>
      <section class="glass-card glass-audio">
        <h2>Ses</h2>
        <div class="glass-audio-controls">
          <button id="muteBtn" class="glass-btn">Mikrofon</button>
          <button id="noiseToggle" class="ghost glass-btn">G√ºr√ºlt√º Engelle</button>
        </div>
        <div class="glass-meter">
          <input id="micLevel" type="range" min="0" max="100" value="0" disabled />
          <div class="meter"><div class="level" id="levelBar"></div></div>
          <span id="micState" class="glass-mic-state"></span>
        </div>
        <div id="remoteAudios" class="glass-remote-audios"></div>
      </section>
      <section class="glass-card glass-chat">
        <h2>Sohbet</h2>
        <div id="chatMessages" class="glass-chat-messages"></div>
        <div class="glass-chat-row">
          <input id="chatInput" placeholder="Mesaj yaz..." class="glass-input" />
          <button id="chatSend" class="glass-btn">G√∂nder</button>
        </div>
      </section>
    </main>
    <footer class="glass-footer">Tarayƒ±cƒ± mikrofon izinleri gereklidir.</footer>
  </div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <script src="rnnoise-wasm.min.js"></script>
  <script>
    // Theme toggle logic
    const themeToggle = document.getElementById('themeToggle');
    function setTheme(theme) {
      if (theme === 'light') {
        document.body.classList.add('light-theme');
        localStorage.setItem('theme', 'light');
        themeToggle.textContent = '‚òÄÔ∏è Koyu';
      } else {
        document.body.classList.remove('light-theme');
        localStorage.setItem('theme', 'dark');
        themeToggle.textContent = 'üåô A√ßƒ±k';
      }
    }
    themeToggle.onclick = function() {
      if (document.body.classList.contains('light-theme')) {
        setTheme('dark');
      } else {
        setTheme('light');
      }
    };
    // On load, set theme from localStorage
    (function(){
      const saved = localStorage.getItem('theme');
      setTheme(saved === 'light' ? 'light' : 'dark');
    })();
    const socket = io();
    let peers = {};
    let localStream = null;
    let currentRoom = "";
    let socketNames = {};
    let myName = null;
    let audioCtx = null;
    let analyser = null;
    let dataArray = null;
    let rafId = null;
    let isMicOn = false;

    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const muteBtn = document.getElementById('muteBtn');
    const micLevel = document.getElementById('micLevel');
    const levelBar = document.getElementById('levelBar');
    const micState = document.getElementById('micState');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');
    const chatMessages = document.getElementById('chatMessages');

    createBtn.onclick = createRoom;
    joinBtn.onclick = joinRoom;
    muteBtn.onclick = toggleMic;
    document.getElementById('setNameBtn').onclick = setName;
    document.getElementById('refreshRooms').onclick = requestRooms;

    function setStatus(msg) { document.getElementById('status').innerText = msg; }

    let noiseSuppressionOn = true;
    let rnnoiseModule = null;
    let rnnoiseProcessor = null;
    async function ensureMic() {
      if (localStream) return localStream;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            noiseSuppression: false, // We'll use RNNoise instead
            echoCancellation: true,
            autoGainControl: true,
            sampleRate: 48000
          }
        });
        if (noiseSuppressionOn && window.RNNoise) {
          if (!rnnoiseModule) {
            rnnoiseModule = await window.RNNoise();
          }
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(stream);
          const dest = audioCtx.createMediaStreamDestination();
          // RNNoise processor node
          if (!rnnoiseProcessor) {
            rnnoiseProcessor = audioCtx.createScriptProcessor(512, 1, 1);
            const frameSize = 480;
            const rnnoise = new rnnoiseModule.RNNoise();
            rnnoiseProcessor.onaudioprocess = function(e) {
              const input = e.inputBuffer.getChannelData(0);
              const output = e.outputBuffer.getChannelData(0);
              for (let i = 0; i < input.length; i += frameSize) {
                const frame = input.slice(i, i + frameSize);
                const denoised = rnnoise.process(frame);
                output.set(denoised, i);
              }
            };
          }
          source.connect(rnnoiseProcessor);
          rnnoiseProcessor.connect(dest);
          localStream = dest.stream;
        } else {
          localStream = stream;
        }
        setupAnalyzer(localStream);
        return localStream;
      } catch (e) {
        setStatus('Mikrofon eri≈üimi reddedildi veya bulunamadƒ±.');
        throw e;
      }
    }

    // Noise suppression toggle logic
    const noiseToggle = document.getElementById('noiseToggle');
    if (noiseToggle) {
      noiseToggle.onclick = async function() {
        noiseSuppressionOn = !noiseSuppressionOn;
        noiseToggle.textContent = 'G√ºr√ºlt√º Engelle: ' + (noiseSuppressionOn ? 'A√ßƒ±k' : 'Kapalƒ±');
        // Stop and re-acquire mic with new setting
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }
        try {
          await ensureMic();
          setStatus('G√ºr√ºlt√º engelleme ' + (noiseSuppressionOn ? 'a√ßƒ±ldƒ±.' : 'kapalƒ±.'));
        } catch (e) {
          setStatus('Mikrofon yeniden ba≈ülatƒ±lamadƒ±.');
        }
      };
    }

    function createRoom() {
      const roomId = document.getElementById('roomId').value;
      if (!roomId) return setStatus('L√ºtfen bir oda ID gir.');
      socket.emit('create-room', roomId);
    }

    function setName(){
      const input = document.getElementById('displayName');
      if (!input) return;
      const name = (input.value || '').trim();
      if (!name) return setStatus('L√ºtfen ge√ßerli bir isim girin.');
      if (name.length > 16) return setStatus('ƒ∞sim 16 karakterden uzun olamaz.');
      socket.emit('set-name', name);
    }

    async function joinRoom() {
      const roomId = document.getElementById('roomId').value;
      if (!roomId) return setStatus('L√ºtfen bir oda ID gir.');
      try {
        await ensureMic();
        socket.emit('join-room', roomId);
      } catch (e) {
        console.error(e);
      }
    }

    socket.on('roomExists', () => setStatus('‚ùå Bu oda zaten var!'));
    socket.on('roomNotFound', () => setStatus('‚ùå B√∂yle bir oda yok.'));
    socket.on('roomFull', () => setStatus('‚ùå Oda dolu (5 ki≈üi sƒ±nƒ±rƒ±).'));

    socket.on('roomCreated', (roomId) => {
      setStatus('‚úÖ Oda olu≈üturuldu.');
      currentRoom = roomId;
      document.getElementById('shareLink').innerText = window.location.origin + '?room=' + roomId;
      // refresh list when a room is created
      requestRooms();
    });

    socket.on('chat-message', (payload) => {
      // payload: { fromId, fromName, text, ts }
      appendChatMessage(payload.fromName || payload.from, payload.text, payload.ts, payload.fromId || payload.from);
    });

    socket.on('name-set', (res) => {
      if (res && res.success) {
        myName = res.name;
        socketNames[socket.id] = res.name;
        setStatus('ƒ∞sim ayarlandƒ±: ' + res.name);
      } else {
        setStatus('ƒ∞sim deƒüi≈ütirilemedi: ' + (res && res.reason ? res.reason : 'hata'));
      }
    });

    socket.on('name-changed', ({ id, name }) => {
      if (!id) return;
      if (name) socketNames[id] = name; else delete socketNames[id];
      // update any remote audio labels
      const labels = document.querySelectorAll('[data-peer-id="' + id + '"]');
      labels.forEach(el => {
        if (el.tagName && el.tagName.toLowerCase() === 'div') {
          el.innerText = 'Kullanƒ±cƒ±: ' + (name || id);
        }
      });
      refreshUsersList();
    });

    socket.on('left-room', (roomId) => {
      if (currentRoom === roomId) {
        setStatus('‚úÖ Odanan ayrƒ±ldƒ±nƒ±z.');
        currentRoom = '';
        document.getElementById('shareLink').innerText = '';
        requestRooms();
        refreshUsersList();
      }
    });

    socket.on('room-deleted', (roomId) => {
      if (currentRoom === roomId) {
        setStatus('‚ö†Ô∏è Oda silindi: ' + roomId);
        currentRoom = '';
        document.getElementById('shareLink').innerText = '';
      }
      requestRooms();
      refreshUsersList();
    });

    socket.on('room-list', (rooms) => {
      const el = document.getElementById('roomsList');
      if (!rooms || !rooms.length) {
        el.innerText = '(hi√ß oda yok)';
        return;
      }
      el.innerHTML = '';
      rooms.forEach(r => {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.justifyContent = 'space-between';
        row.style.alignItems = 'center';
        row.style.marginBottom = '6px';

        const label = document.createElement('div');
        label.style.color = 'var(--muted)';
        label.innerText = `${r.id}  ‚Äî  ${r.size} ki≈üi`;
        if (r.id === currentRoom) {
          label.innerText += '   (joined)';
          label.style.fontWeight = '600';
          label.style.color = 'var(--accent)';
        }

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '6px';

        const joinBtn = document.createElement('button');
        joinBtn.innerText = 'Katƒ±l';
        joinBtn.onclick = () => { document.getElementById('roomId').value = r.id; joinRoom(); };

        const leaveBtn = document.createElement('button');
        leaveBtn.innerText = 'Ayrƒ±l';
        leaveBtn.style.background = 'transparent';
        leaveBtn.style.color = 'var(--muted)';
        leaveBtn.onclick = () => { socket.emit('leave-room', r.id); };

        const delBtn = document.createElement('button');
        delBtn.innerText = 'Sil';
        delBtn.style.background = 'transparent';
        delBtn.style.color = '#ff7b7b';
        delBtn.onclick = () => {
          if (!confirm('Bu odayƒ± silmek istediƒüinizden emin misiniz?')) return;
          socket.emit('delete-room', r.id);
        };

        // show appropriate buttons
        actions.appendChild(joinBtn);
        actions.appendChild(leaveBtn);
        actions.appendChild(delBtn);

        row.appendChild(label);
        row.appendChild(actions);
        el.appendChild(row);
      });
    });

    socket.on('joinedRoom', async (roomId, others, history, names) => {
      setStatus('‚úÖ Odaya katƒ±ldƒ±n.');
      currentRoom = roomId;
      document.getElementById('shareLink').innerText = window.location.origin + '?room=' + roomId;
      if (!localStream) await ensureMic();

      // render chat history for this room (WhatsApp-like)
      chatMessages.innerHTML = '';
      // save known names mapping for this room
      socketNames = names || {};
      // update myName if server knows it
      if (socketNames[socket.id]) myName = socketNames[socket.id];
      if (Array.isArray(history) && history.length) {
        history.forEach(m => appendChatMessage(m.fromName || m.from, m.text, m.ts, m.fromId || m.from));
      }

      socket.on('user-joined', (payload) => {
        const id = payload && payload.id ? payload.id : payload;
        const name = payload && payload.name ? payload.name : null;
        if (name) socketNames[id] = name;
        const peer = createPeer(id);
        peers[id] = peer;
        // attach tracks
        localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
      });

      socket.on('signal', ({ from, data }) => {
        if (!peers[from]) {
          const peer = createPeer(from, false);
          peers[from] = peer;
        }
        peers[from].signal(data);
      });

      socket.on('user-left', (id) => {
        if (peers[id]) {
          peers[id].destroy();
          delete peers[id];
        }
        // remove name mapping
        if (socketNames[id]) delete socketNames[id];
        refreshUsersList();
      });
      refreshUsersList();
    });

    function createPeer(id, initiator = true) {
      const peer = new SimplePeer({
        initiator,
        trickle: false,
        stream: localStream,
        config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
      });

      peer.on('signal', data => socket.emit('signal', { to: id, data }));

      peer.on('stream', stream => {
        // append remote audio to container
        const container = document.getElementById('remoteAudios');
        const wrapper = document.createElement('div');
        wrapper.className = 'card';
        wrapper.dataset.peerId = id;
        const label = document.createElement('div');
        label.style.fontSize = '13px';
        label.style.color = 'var(--muted)';
        const display = socketNames[id] || id;
        label.innerText = 'Kullanƒ±cƒ±: ' + display;
        label.dataset.peerId = id;
        const audio = document.createElement('audio');
        audio.srcObject = stream;
        audio.autoplay = true;
        audio.controls = true;
        wrapper.appendChild(label);
        wrapper.appendChild(audio);
        container.appendChild(wrapper);
        refreshUsersList();
      });

      peer.on('connect', () => { refreshUsersList(); });

      return peer;
    }

    function refreshUsersList(){
      const el = document.getElementById('user-list');
      if (!el) return;
      el.innerHTML = '';
      const ids = Object.keys(peers);
      // show current user first (if available)
      if (socket && socket.id) {
        const display = myName || socketNames[socket.id] || socket.id;
        const li = document.createElement('li');
        li.textContent = '‚Ä¢ ' + display + '  (you)';
        el.appendChild(li);
      }
      // then show other connected peers
      ids.forEach(id => {
        if (id === socket.id) return;
        const display = socketNames[id] || id;
        const li = document.createElement('li');
        li.textContent = '‚Ä¢ ' + display;
        el.appendChild(li);
      });
      if (el.children.length === 0) {
        const li = document.createElement('li');
        li.textContent = '(hi√ß kimse)';
        el.appendChild(li);
      }
    }

    function setupAnalyzer(stream){
      try{
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        const bufferLength = analyser.fftSize;
        dataArray = new Uint8Array(bufferLength);
        source.connect(analyser);
        isMicOn = true;
        micState.innerText = 'Durum: A√ßƒ±k';
        muteBtn.innerText = 'Mikrofonu Kapat';
        animateMeter();
      }catch(e){
        console.warn('Analyzer setup failed', e);
      }
    }

    function animateMeter(){
      if (!analyser) return;
      analyser.getByteTimeDomainData(dataArray);
      // compute RMS
      let sum = 0;
      for(let i=0;i<dataArray.length;i++){
        const v = (dataArray[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / dataArray.length);
      const level = Math.min(100, Math.round(rms * 200));
      micLevel.value = level;
      levelBar.style.width = level + '%';
      rafId = requestAnimationFrame(animateMeter);
    }

    async function toggleMic(){
      if (!localStream){
        try{ await ensureMic(); }
        catch{return}
      }
      const tracks = localStream.getAudioTracks();
      if (!tracks.length) return;
      const enabled = tracks[0].enabled;
      tracks.forEach(t => t.enabled = !enabled);
      isMicOn = !enabled;
      micState.innerText = 'Durum: ' + (isMicOn ? 'A√ßƒ±k' : 'Kapalƒ±');
      muteBtn.innerText = isMicOn ? 'Mikrofonu Kapat' : 'Mikrofonu A√ß';
      if (!isMicOn){ micLevel.value = 0; levelBar.style.width = '0%'; }
    }

    // handle ngrok help button
    document.getElementById('ngrokHelp').onclick = () => {
      alert('ngrok kullanƒ±mƒ± i√ßin hesabƒ±nƒ±za authtoken ekleyin. README dosyasƒ±na bakƒ±n.');
    };

    // parse room param on load
    window.onload = () => {
      const params = new URLSearchParams(window.location.search);
      const room = params.get('room');
      if (room) {
        document.getElementById('roomId').value = room;
        joinRoom();
      }
      // request existing rooms on load
      requestRooms();
    };

    function requestRooms(){
      socket.emit('get-rooms');
    }

    function appendChatMessage(fromName, text, ts, fromId){
      const row = document.createElement('div');
      row.className = 'chat-message';
      const id = fromId || fromName;
      const display = (id === socket.id) ? ((myName || socketNames[socket.id] || socket.id) + ' (you)') : (fromName || id);
      const time = ts ? new Date(ts).toLocaleTimeString() : '';
      row.innerHTML = `<div class="chat-meta">${escapeHtml(display)} <span style='float:right;font-size:11px;color:rgba(255,255,255,0.2)'>${time}</span></div><div>${escapeHtml(text)}</div>`;
      chatMessages.appendChild(row);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function escapeHtml(unsafe){
      return unsafe.replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]; });
    }

    chatSend.onclick = () => {
      const text = chatInput.value && chatInput.value.trim();
      if (!text) return;
      if (!currentRoom) { setStatus('√ñnce bir odaya katƒ±lƒ±n.'); return; }
      socket.emit('chat-message', { roomId: currentRoom, text, fromName: myName || socketNames[socket.id] || socket.id });
      chatInput.value = '';
    };

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); chatSend.click(); }
    });

    // Listen for chat-message event to display incoming messages
    socket.on('chat-message', (msg) => {
      appendChatMessage(msg.fromName || msg.from, msg.text, msg.ts, msg.fromId || msg.from);
    });

  </script>
</body>
</html>
